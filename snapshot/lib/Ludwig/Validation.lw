@language("no-prelude")

import
    Ludwig.List   as List
    Ludwig.String as String
    Ludwig.Error  as Error

export
    type Validation
    success
    failure

    isSuccess
    isFailure

    toErrorAt

    getFailureMessage
    addPrefix

    and
    join
    assert

    optional

# The validation type.
#
# *DEPRECATED*: The constructors of this type should not be used directly.  Use
# `success` or `failure` instead.
type Validation:
    | Success
    | Failure String

# Return a 'Success' value
Validation success: Success

# Check if a validation was successful.
fun isSuccess(val: Validation) -> Bool:
  case val of
    | Success   -> True
    | Failure _ -> False

# Raise a validation failure.
fun failure(err: String) -> Validation: Failure(err)

# Check if a validation failed.
fun isFailure(val: Validation) -> Bool:
  case val of
    | Success   -> False
    | Failure _ -> True

# Convert the validation to an error using `errorAt` (if there is any).  If the
# validation is successful, just return the unit `()`.
fun toErrorAt(n: Int, val: Validation) -> ():
  case val of
    | Success     -> ()
    | Failure err -> Error.errorAt(__Ludwig_Int_add(n, 1), err)

# Get the failure message.  If the validation is a success, this will return the
# empty string.
fun getFailureMessage(val: Validation) -> String:
  case val of
    | Success   -> ""
    | Failure e -> e

# Add a prefix to the error message.  In case this is a successful validation,
# we don't do anything.
fun addPrefix(prefix: String, val: Validation) -> Validation:
  case val of
    | Success     -> Success
    | Failure str -> Failure(String.concat(prefix, str))

# Create a 'Validation' from a 'Bool' value.
fun assert(err: String, test: Bool) -> Validation:
    if test then success else failure(err)

# Combine two validations, ensuring that they both pass.
#
# Example:
#
#     valid:    and(success, success)           # => success
#     invalid1: and(failure("A"), success)      # => failure("A")
#     invalid2: and(success, failure("B"))      # => failure("B")
#     invalid3: and(failure("A"), failure("B")) # => failure("A")
fun and(x: Validation, y: Validation) -> Validation:
    case x of
        | Success     -> y
        | Failure _   -> x

# Reduce a list of Validations into a single value.
#
# Example usage:
#
#     invalid1: join([Success, Success, Failure("boom"), Success]) # => Failure("boom")
#     invalid2: join([Failure("A"), Failure("B")])                 # => Failure("A")
#     valid: join([Success, Success])                              # => Success
#
# @arg validations The list of validations to combine.
#
# @return A single validation that is the result of `and`ing all of
# the supplied validations together.
fun join(validations: List<Validation>) -> Validation:
    List.fold(and, Success, validations)

# Apply a validation on an optional.  If there is no value, the 'Validation' is
# successfull.
fun optional(f: fun(a) -> Validation, x: Optional<a>) -> Validation:
    case x of
        | None       -> success
        | Optional y -> f(y)
