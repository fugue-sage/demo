# This module provides regular expression suport for Ludwig.
#
#
# There are many different flavours of regular expressions.  This module
# supports specifically POSIX extended regular expressions (ERE).  More
# information these regular expressions can be found here:
# <https://en.wikipedia.org/wiki/Regular_expression#POSIX_extended>.
#
# The regexes provided by this module support Unicode, _except_ the different
# character classes: e.g., `[:alpha:]` will match `"l"` but not `"Î»"`.
@language("no-prelude")

import Ludwig.Optional as Optional
import Ludwig.List as List
import Ludwig.String as String
import Ludwig.Int as Int

# A compiled regular expression.  These can be constructed using the `new`
# function.
type opaque Regex

# Create a new regular expression.
#
# Examples:
#
#     sha1: Regex.new {pattern: "^[:xdigit:]{40}$"}
#     ami: Regex.new {pattern: "ami-[:xdigit:]+"}
#     float: Regex.new {pattern: "[:digit:]+(\\.[:digit:]+)?"}
#
# **Escaping**
#
# Note that if you are creating a regex from a raw string, you will need to
# double-escape backslashes.  For example, if you want to match the literal
# string `[]`, you need to use:
#
#     Regex.new {pattern: "\\[\\]"}
#
# @arg pattern The string to compile.
# @arg caseSensitive Compile a case-sensitive regex.  Defaults to `True`.
# @arg multiLine Compile a regex that can match over multiple lines.  Defaults
# to `False`.
# @return The compiled regex.
fun new {
  pattern: String,
  caseSensitive: Optional<Bool>,
  multiLine: Optional<Bool>
} -> Regex:
  __Ludwig_Regex_new(
    pattern,
    Optional.unpack(True, caseSensitive),
    Optional.unpack(False, multiLine)
  )

# Match a regex against an input `String`.
#
# This will match the regex anywhere in the input `String`.  If you do not want
# that, use `"^"` and `"$"` to _anchor_ the `Regex`.
#
# @arg regex The regex to match.
# @arg input The input string.
# @return The full list of matches.
fun match {
  regex: Regex,
  input: String
} -> List<Match>:
  __Ludwig_Regex_match(regex, input)

# A single match.
#
# @field range The range of the "whole match".
# @field groups The ranges of the submatches (if any).
type Match:
  range: Range
  groups: List<Range>

# A range of text that was matched by a regex.
#
# @field contents The contents of the match.
# @field start The absolute, 0-based offset in the input string.
# @field length The length of the match.
type Range:
  contents: String
  start: Int
  length: Int

# This is a utility function that, instead of returning all the different
# matches like `match`, just tells you whether or not there was at least one
# match.
#
# @arg regex The regex to match.
# @arg input The input string.
# @return Was there at least one match?
fun matches {
  regex: Regex,
  input: String
} -> Bool:
  Int.gt(List.length(match{regex: regex, input: input}), 0)

# This is how the replacement is computed from a match.
type Replacement: fun(Match) -> String

# Replace occurences of the regex in the input string using a 'Replacement'.
#
# By default, this will replace _all_ occurences.  If you only want to replace
# one, use 1 for the `limit` argument.
#
# The 'replacement' argument is very flexible, because it is a function that
# computes the replacement string from the match.  Some examples should make
# this clear:
#
# 1. We can replace the matches by a fixed string by using a function that
#    always returns the same value:
#
#         Regex.sub {
#           regex: Regex.new {pattern: '[:digit:]+'},
#           input: '1 lemonade and 2 ice-tea please',
#           replacement: fun(_): "100"
#         } # => '100 lemonade and 100 ice-tea please'
#
# 2. We can use the `backrefs` function to work with traditional
#    back-references.  In that case, `\0` refers to the whole match, `\1`
#    referes to the match first group, and so on.  We need to double-escape
#    the backslashes here as well.
#
#         Regex.sub {
#           regex: Regex.new {pattern: '[:digit:]+'},
#           input: '1 lemonade and 2 ice-tea please',
#           replacement: Regex.backrefs('\\0 big')
#         } # => '1 big lemonade and 2 big ice-tea please'
#
# 3. We can use a custom function to replace the string, for example
#    incrementing integers by one:
#
#         Regex.sub {
#           regex: Regex.new {pattern: '[:digit:]+'},
#           input: '1 lemonade and 2 ice-tea please',
#           replacement: fun(m): case String.toInt(m.range.contents) of
#             | Optional i -> Int.toString(i + 1)
#             | _          -> '?'
#         } # => '2 lemonade and 3 ice-tea please'
#
# @arg regex The regex to replace.
# @arg limit Maximum number of replacements.  Defaults to no limit (replace
# everything).
# @arg replacement How to replace the matches.
# @return A new String with the replacements.
fun sub {
  regex: Regex,
  input: String,
  replacement: Replacement,
  limit: Optional<Int>,
} -> String:
  # Worker function
  let fun go(
        matches0: List<Match>,  # Remaining matches to replace
        idx0: Int,              # Index in the original input string
        num0: Int               # Number of replacement we've made already
      ) -> String:
        case List.uncons(matches0) of
          | None ->
            # No more subsitutions.
            String.drop(idx0, input)
          | Optional (m, matches1) ->
            if Optional.mapUnpack(True, fun(l): Int.lt(num0, l), limit) then
              # There's a match and we haven't reached the limit yet.
              String.concat(
                # Concat: The part before the match.
                String.take(Int.sub(m.range.start, idx0),
                  String.drop(idx0, input)),
                String.concat(
                  # Concat: The replacement of the match.
                  replacement(m),
                  # Concat: The part after the match.
                  go(
                    matches1,
                    Int.add(m.range.start, m.range.length),
                    Int.add(num0, 1))))
            else
              # We've reached the limit.
              String.drop(idx0, input)

  # Start!
  go(match {input: input, regex: regex}, 0, 0)

# Construct a 'Replacement' using traditional back-references.
#
# For more info, see the documentation for `sub`.
#
# @arg template Template where backreferences should be spliced in.
# @return The resulting 'Replacement'.
fun backrefs(template: String) -> Replacement:
  fun(match): __Ludwig_Regex_backrefs(template, match)

# Split a string according to a regex.
#
# You can limit the number of times the string is split by specifying the
# `limit` argument.  If the limit is _N_, the maximum number of elements in the
# resulting list is naturally _N + 1_.
#
# Examples:
#
#     split01: Regex.split {
#       regex: Regex.new {pattern: '[:space:]+'},
#       input: 'So call    me maybe'
#     } # => ['So', 'call', 'me', 'maybe']
#
#     split02: Regex.split {
#       regex: Regex.new {pattern: ',[:space:]*'},
#       input: 'Tim, 24, Finance, 4,,No'
#     } # => ['Tim', '24', 'Finance', '4', '', 'No']
#
# @arg regex Regex to split on.
# @arg input Input string to split.
# @arg limit Maximum number of splits.  Defaults to no limit.
# @return List of the substrings, split by the given regex.
fun split {
  regex: Regex,
  input: String,
  limit: Optional<Int>,
} -> List<String>:
  # Worker function
  let fun go(
        matches0: List<Match>,  # Remaining matches to split on
        idx0: Int,              # Index in the original input string
        num0: Int               # Number of replacement we've made already
      ) -> List<String>:
        case List.uncons(matches0) of
          | None ->
            # No more subsitutions.
            [String.drop(idx0, input)]
          | Optional (m, matches1) ->
            if Optional.mapUnpack(True, fun(l): Int.lt(num0, l), limit) then
              # There's a match and we haven't reached the limit yet.
              List.cons(
                String.take(Int.sub(m.range.start, idx0),
                  String.drop(idx0, input)),
                  go(
                    matches1,
                    Int.add(m.range.start, m.range.length),
                    Int.add(num0, 1)))
            else
              # We've reached the limit.
              [String.drop(idx0, input)]

  # Start!
  go(match {input: input, regex: regex}, 0, 0)
