@language("no-prelude")

import Ludwig.Bool as Bool

# Test for deep structural equality of two values.
#
# Example:
#
#     x: structuralEquality(1, 1)                # => True
#     y: structuralEquality({foo: 1}, {foo: 1})  # => True
#     z: structuralEquality({foo: 1}, {foo: 2})  # => False
#
# Comparing functions for equality will always result in `False`.
#
#     x: structuralEquality(fun x: x, fun x: x)  # => False
#
# This implies that comparing data structures with embedded functions such as
# this one will also always result in false:
#
#     type Curve:
#       name: String
#       y:    fun(Int) -> Int
#
# Another important thing to note is that comparing cyclical values for
# structural equality will not work, since that results in an infinite loop.
#
# @arg x First value
# @arg y Second value
# @return Whether or not the two values are structurally equal.
fun structuralEquality(x: a, y: a) -> Bool:
    __Ludwig_Equality_structuralEquality(x, y)

# Test if two values are *not* structurally equal.  The opposite of
# `structuralEquality`.
fun structuralInequality(x: a, y: a) -> Bool:
    Bool.not(structuralEquality(x, y))

# Structural equality test.  See `structuralEquality`.
operator == infixl 4: structuralEquality

# Structural inequality test.  See `structuralInequality`.
operator != infixl 4: structuralInequality
