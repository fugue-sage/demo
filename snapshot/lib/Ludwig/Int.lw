@language("no-prelude")

import Ludwig.Error
import Ludwig.Equality
import Ludwig.Optional

export
    add
    sub
    mul
    div
    mod
    pow
    and
    or
    xor
    shiftL
    shiftR
    negate

    operator +
    operator -
    operator *
    operator /
    operator %
    operator ^

    eq
    neq
    lt
    lte
    gt
    gte

    operator Ludwig.Equality.==
    operator Ludwig.Equality.!=
    operator <
    operator <=
    operator >
    operator >=

    toString
    range

fun add(x: Int, y: Int) -> Int: __Ludwig_Int_add(x, y)
fun sub(x: Int, y: Int) -> Int: __Ludwig_Int_sub(x, y)
fun mul(x: Int, y: Int) -> Int: __Ludwig_Int_mul(x, y)
fun and(x: Int, y: Int) -> Int: __Ludwig_Int_and(x, y)
fun or(x: Int, y: Int) -> Int: __Ludwig_Int_or(x, y)
fun xor(x: Int, y: Int) -> Int: __Ludwig_Int_xor(x, y)
fun shiftL(x: Int, y: Int) -> Int: __Ludwig_Int_shiftl(x, y)
fun shiftR(x: Int, y: Int) -> Int: __Ludwig_Int_shiftr(x, y)

fun div(x: Int, y: Int) -> Int:
  if __Ludwig_Int_eq(y, 0) then
    Ludwig.Error.error("Ludwig.Int.div: Divide by zero")
  else
    __Ludwig_Int_div(x, y)

fun mod(x: Int, y: Int) -> Int:
  if __Ludwig_Int_eq(y, 0) then
    Ludwig.Error.error("Ludwig.Int.mod: Divide by zero")
  else
    __Ludwig_Int_mod(x, y)

fun pow(x: Int, y: Int) -> Int:
  if __Ludwig_Int_lt(y, 0) then
    Ludwig.Error.error("Ludwig.Int.pow: Negative exponent")
  else
    __Ludwig_Int_pow(x, y)

# Negate an `Int`.
#
# Note that this is currently the only way to specify a negative literal.
#
# Example:
#
#     negative1: negate(1)           # => -1
#     positive1: negate(negative1)   # => 1
fun negate(x: Int) -> Int: __Ludwig_Int_negate(x)

# Addition operator for `Int`s.
operator + infixl 6: add

# Subtraction operator for `Int`s.
operator - infixl 6: sub

# Multiplication operator for `Int`s.
operator * infixl 7: mul

# Division operator for `Int`s.
operator / infixl 7: div

# Modulo operator for `Int`s.
operator % infixl 7: mod

# Exponent operator for `Int`s.
operator ^ infixr 8: pow

fun eq(x: Int, y: Int)  -> Bool: __Ludwig_Int_eq(x, y)
fun neq(x: Int, y: Int) -> Bool: __Ludwig_Int_neq(x, y)
fun lt(x: Int, y: Int)  -> Bool: __Ludwig_Int_lt(x, y)
fun lte(x: Int, y: Int) -> Bool: __Ludwig_Int_lte(x, y)
fun gt(x: Int, y: Int)  -> Bool: __Ludwig_Int_gt(x, y)
fun gte(x: Int, y: Int) -> Bool: __Ludwig_Int_gte(x, y)

# Less than operator for `Int`s.
operator <  infixl 4: lt

# Less than or equal operator for `Int`s.
operator <= infixl 4: lte

# Greater than operator for `Int`s.
operator >  infixl 4: gt

# Greater than or equal operator for `Int`s.
operator >= infixl 4: gte

# Convert an `Int` to a `String`.
#
# Example:
#
#     x1: toString(42)        # => "42"
#     x2: toString(negate(1)) # => "-1"
#
# @arg n The `String` to convert.
# @return `n` as a `String`.
fun toString(n: Int) -> String: __Ludwig_Int_toString(n)

# Generate a list of `Int`s, separated by `step` value and optionally inclusive of `to`.
#
# Example:
#
#     xsa: Int.range{to: 5}                     # => [0,1,2,3,4,5]
#     xsb: Int.range{to: 5, step: 2}            # => [0,2,4]
#     xsc: Int.range{from: 1, to: 5}            # => [1,2,3,4,5]
#     xsd: Int.range{to: 5, inclusive: False}   # => [0,1,2,3,4]
#     xs: String.join('', [ Int.toString(x) for x in Int.range{to: 5} ])  # => "012345"
#
# @arg from The beginning of the range.
# @arg to The end of the range.
# @arg inclusive Whether to include the `to` value. If addition of
#                `step` exceeds `to`, this is overridden to `False`.
# @arg step The difference between each number in the list.
# @return The list of integers, as specified.
fun range{from: Optional<Int>, to: Int, inclusive: Optional<Bool>, step: Optional<Int>} -> List<Int>:
    let f: Ludwig.Optional.unpack(0, from)
    let i: Ludwig.Optional.unpack(True, inclusive)
    let s: Ludwig.Optional.unpack(1, step)
    if __Ludwig_Int_eq(f, to) then
        if i then [to] else []
    elif __Ludwig_Int_gt(f, to) then []
    else
        __Ludwig_List_cons(f, range{from: f + s, to: to, inclusive: i , step: s})
